---
section: 上站流程
nav_order: 3
title: 5.1.3 模板与API对接基础
---
> 模板系统和API对接是将内容与展示分离的核心技术。本节介绍模板系统设计原则、RESTful/GraphQL API对接方式以及Headless架构的实践方法。

## 模板系统在SEO中的作用

模板系统决定了页面HTML的结构和语义化程度，直接影响搜索引擎对页面内容的理解。良好的模板设计应该：

- **语义化HTML**：使用正确的标签层级（h1-h6、article、nav、main等）
- **统一的Meta输出**：确保每个页面都有完整的SEO元信息
- **结构化数据嵌入**：在模板层面集成Schema Markup
- **性能优化**：模板层控制资源加载策略

## 通用SEO基础模板设计

### HTML语义化结构

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- SEO核心Meta标签（由模板变量填充） -->
    <title>{{ page.title }} | {{ site.name }}</title>
    <meta name="description" content="{{ page.description }}">
    <link rel="canonical" href="{{ page.canonical_url }}">

    <!-- 社交分享 -->
    <meta property="og:title" content="{{ page.title }}">
    <meta property="og:description" content="{{ page.description }}">
    <meta property="og:image" content="{{ page.og_image }}">
    <meta property="og:url" content="{{ page.canonical_url }}">
    <meta property="og:type" content="{{ page.og_type | default: 'website' }}">

    <!-- 多语言 -->
    {% for lang in site.languages %}
    <link rel="alternate" hreflang="{{ lang.code }}" href="{{ lang.url }}">
    {% endfor %}

    <!-- 结构化数据 -->
    <script type="application/ld+json">{{ page.structured_data | json }}</script>

    <!-- 预加载关键资源 -->
    <link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preconnect" href="https://cdn.example.com">
</head>
<body>
    <header role="banner">
        <nav aria-label="Main navigation">
            {{ navigation }}
        </nav>
    </header>

    <!-- 面包屑导航 -->
    <nav aria-label="Breadcrumb">
        <ol itemscope itemtype="https://schema.org/BreadcrumbList">
            {% for crumb in page.breadcrumbs %}
            <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                <a itemprop="item" href="{{ crumb.url }}">
                    <span itemprop="name">{{ crumb.title }}</span>
                </a>
                <meta itemprop="position" content="{{ forloop.index }}">
            </li>
            {% endfor %}
        </ol>
    </nav>

    <main role="main" id="main-content">
        {{ content }}
    </main>

    <footer role="contentinfo">
        {{ footer }}
    </footer>
</body>
</html>
```

### 文章页模板

```html
<!-- templates/article.html -->
<article itemscope itemtype="https://schema.org/Article">
    <header>
        <h1 itemprop="headline">{{ article.title }}</h1>
        <div class="meta">
            <time itemprop="datePublished" datetime="{{ article.published_at | iso8601 }}">
                {{ article.published_at | format_date }}
            </time>
            <time itemprop="dateModified" datetime="{{ article.updated_at | iso8601 }}" hidden>
                {{ article.updated_at | format_date }}
            </time>
            <span itemprop="author" itemscope itemtype="https://schema.org/Person">
                <span itemprop="name">{{ article.author.name }}</span>
            </span>
        </div>
    </header>

    <!-- 目录（Table of Contents）-->
    {% if article.toc.length > 0 %}
    <nav class="toc" aria-label="Table of contents">
        <h2>目录</h2>
        <ol>
            {% for item in article.toc %}
            <li><a href="#{{ item.id }}">{{ item.title }}</a></li>
            {% endfor %}
        </ol>
    </nav>
    {% endif %}

    <div itemprop="articleBody" class="content">
        {{ article.content }}
    </div>

    <!-- 相关文章（内部链接） -->
    <aside>
        <h2>相关文章</h2>
        <ul>
            {% for related in article.related_articles %}
            <li>
                <a href="{{ related.url }}">{{ related.title }}</a>
                <p>{{ related.excerpt }}</p>
            </li>
            {% endfor %}
        </ul>
    </aside>
</article>
```

### 列表页模板

```html
<!-- templates/listing.html -->
<section>
    <h1>{{ category.name }}</h1>
    <p>{{ category.description }}</p>

    <div class="article-list" role="feed" aria-label="Articles">
        {% for article in articles %}
        <article aria-posinset="{{ forloop.index }}" aria-setsize="{{ articles.length }}">
            <h2>
                <a href="{{ article.url }}">{{ article.title }}</a>
            </h2>
            <p>{{ article.excerpt }}</p>
            <time datetime="{{ article.published_at | iso8601 }}">
                {{ article.published_at | format_date }}
            </time>
        </article>
        {% endfor %}
    </div>

    <!-- 分页导航 -->
    <nav aria-label="Pagination">
        {% if pagination.prev %}
        <a href="{{ pagination.prev }}" rel="prev">上一页</a>
        {% endif %}

        <span>第 {{ pagination.current }} 页，共 {{ pagination.total }} 页</span>

        {% if pagination.next %}
        <a href="{{ pagination.next }}" rel="next">下一页</a>
        {% endif %}
    </nav>
</section>
```

## RESTful API 对接

### API数据获取与SEO数据映射

```typescript
// lib/api.ts - RESTful API 封装
interface SEOData {
  title: string;
  description: string;
  canonicalUrl: string;
  ogImage: string;
  structuredData: object;
  noIndex?: boolean;
}

interface Article {
  id: number;
  title: string;
  slug: string;
  content: string;
  excerpt: string;
  seo: SEOData;
  author: { name: string; avatar: string };
  publishedAt: string;
  updatedAt: string;
  category: { name: string; slug: string };
  tags: Array<{ name: string; slug: string }>;
}

const API_BASE = process.env.API_BASE_URL;

// 获取文章列表（带SEO字段）
export async function getArticles(params: {
  page?: number;
  perPage?: number;
  category?: string;
}): Promise<{ data: Article[]; total: number; pages: number }> {
  const query = new URLSearchParams({
    page: String(params.page || 1),
    per_page: String(params.perPage || 20),
    ...(params.category && { category: params.category }),
    fields: 'id,title,slug,excerpt,seo,publishedAt,category,tags',
  });

  const res = await fetch(`${API_BASE}/articles?${query}`, {
    next: { revalidate: 3600 },
  });

  if (!res.ok) throw new Error(`API Error: ${res.status}`);
  return res.json();
}

// 获取单篇文章（完整内容+SEO数据）
export async function getArticleBySlug(slug: string): Promise<Article> {
  const res = await fetch(`${API_BASE}/articles/slug/${slug}?populate=seo,author,category,tags`, {
    next: { revalidate: 1800 },
  });

  if (!res.ok) {
    if (res.status === 404) return null;
    throw new Error(`API Error: ${res.status}`);
  }
  return res.json();
}

// 获取所有slug用于静态生成
export async function getAllSlugs(): Promise<string[]> {
  const res = await fetch(`${API_BASE}/articles?fields=slug&per_page=9999`);
  const data = await res.json();
  return data.data.map((item: { slug: string }) => item.slug);
}
```

### Next.js 页面组件对接

```typescript
// app/blog/[slug]/page.tsx
import { getArticleBySlug, getAllSlugs } from '@/lib/api';
import { notFound } from 'next/navigation';
import type { Metadata } from 'next';

// 静态生成所有文章路径
export async function generateStaticParams() {
  const slugs = await getAllSlugs();
  return slugs.map((slug) => ({ slug }));
}

// 动态生成SEO Metadata
export async function generateMetadata({ params }): Promise<Metadata> {
  const article = await getArticleBySlug(params.slug);
  if (!article) return {};

  return {
    title: article.seo.title,
    description: article.seo.description,
    alternates: {
      canonical: article.seo.canonicalUrl,
    },
    openGraph: {
      title: article.seo.title,
      description: article.seo.description,
      images: [article.seo.ogImage],
      type: 'article',
      publishedTime: article.publishedAt,
      modifiedTime: article.updatedAt,
      authors: [article.author.name],
    },
    robots: article.seo.noIndex ? { index: false } : undefined,
  };
}

// 页面组件
export default async function ArticlePage({ params }) {
  const article = await getArticleBySlug(params.slug);
  if (!article) notFound();

  // JSON-LD 结构化数据
  const jsonLd = {
    '@context': 'https://schema.org',
    '@type': 'Article',
    headline: article.title,
    description: article.excerpt,
    image: article.seo.ogImage,
    datePublished: article.publishedAt,
    dateModified: article.updatedAt,
    author: {
      '@type': 'Person',
      name: article.author.name,
    },
  };

  return (
    <>
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <article>
        <h1>{article.title}</h1>
        <div dangerouslySetInnerHTML={{ __html: article.content }} />
      </article>
    </>
  );
}
```

## GraphQL API 对接

GraphQL 允许精确请求所需字段，减少数据传输量。

### GraphQL查询设计

```graphql
# queries/articles.graphql

# 列表页查询 - 只获取必要字段
query GetArticles($page: Int!, $perPage: Int!, $category: String) {
  articles(
    pagination: { page: $page, pageSize: $perPage }
    filters: { category: { slug: { eq: $category } } }
    sort: "publishedAt:desc"
  ) {
    data {
      id
      attributes {
        title
        slug
        excerpt
        publishedAt
        category {
          data {
            attributes {
              name
              slug
            }
          }
        }
      }
    }
    meta {
      pagination {
        total
        pageCount
      }
    }
  }
}

# 详情页查询 - 获取完整SEO数据
query GetArticleBySlug($slug: String!) {
  articles(filters: { slug: { eq: $slug } }) {
    data {
      attributes {
        title
        slug
        content
        excerpt
        publishedAt
        updatedAt
        author {
          data {
            attributes {
              name
              avatar { data { attributes { url } } }
            }
          }
        }
        seo {
          metaTitle
          metaDescription
          canonicalUrl
          ogImage { data { attributes { url width height } } }
          noIndex
          structuredData
        }
        relatedArticles {
          data {
            attributes {
              title
              slug
              excerpt
            }
          }
        }
      }
    }
  }
}

# Sitemap数据查询
query GetAllSlugsForSitemap {
  articles(pagination: { limit: -1 }, sort: "updatedAt:desc") {
    data {
      attributes {
        slug
        updatedAt
        category {
          data {
            attributes { slug }
          }
        }
      }
    }
  }
}
```

### GraphQL 客户端封装

```typescript
// lib/graphql-client.ts
import { GraphQLClient } from 'graphql-request';

const client = new GraphQLClient(process.env.GRAPHQL_ENDPOINT!, {
  headers: {
    Authorization: `Bearer ${process.env.API_TOKEN}`,
  },
});

export async function fetchGraphQL<T>(
  query: string,
  variables?: Record<string, any>,
  revalidate: number = 3600
): Promise<T> {
  try {
    // 在Next.js中利用fetch缓存
    const res = await fetch(process.env.GRAPHQL_ENDPOINT!, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${process.env.API_TOKEN}`,
      },
      body: JSON.stringify({ query, variables }),
      next: { revalidate },
    });

    const json = await res.json();

    if (json.errors) {
      console.error('GraphQL Errors:', json.errors);
      throw new Error('GraphQL query failed');
    }

    return json.data;
  } catch (error) {
    console.error('GraphQL fetch error:', error);
    throw error;
  }
}
```

## Headless架构实践要点

### 架构图解

```
┌─────────────┐     ┌─────────────┐     ┌─────────────────┐
│  内容编辑者   │────▶│ Headless CMS │────▶│  API (REST/      │
│  (后台管理)   │     │ (内容管理)    │     │  GraphQL)        │
└─────────────┘     └─────────────┘     └────────┬────────┘
                                                  │
                    ┌─────────────────────────────┼──────────────────┐
                    │                             │                  │
              ┌─────▼─────┐              ┌───────▼──────┐   ┌──────▼──────┐
              │   Web前端   │              │  移动App     │   │  其他渠道    │
              │(Next.js等)  │              │             │   │             │
              └─────┬─────┘              └──────────────┘   └─────────────┘
                    │
              ┌─────▼─────┐
              │  CDN/Edge  │
              │  (全球分发)  │
              └───────────┘
```

### 缓存策略设计

```typescript
// middleware.ts - 缓存策略中间件
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const response = NextResponse.next();
  const path = request.nextUrl.pathname;

  // 静态页面 - 长期缓存 + CDN
  if (path.match(/^\/(about|contact|privacy)/)) {
    response.headers.set(
      'Cache-Control',
      'public, s-maxage=86400, stale-while-revalidate=43200'
    );
  }

  // 博客文章 - 中等缓存
  if (path.startsWith('/blog/')) {
    response.headers.set(
      'Cache-Control',
      'public, s-maxage=3600, stale-while-revalidate=1800'
    );
  }

  // 列表页 - 短期缓存
  if (path === '/blog' || path.startsWith('/category/')) {
    response.headers.set(
      'Cache-Control',
      'public, s-maxage=600, stale-while-revalidate=300'
    );
  }

  return response;
}
```

### Webhook驱动的增量更新

```typescript
// app/api/revalidate/route.ts - CMS内容更新时触发
import { revalidatePath, revalidateTag } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  const secret = request.headers.get('x-webhook-secret');
  if (secret !== process.env.REVALIDATION_SECRET) {
    return NextResponse.json({ error: 'Invalid secret' }, { status: 401 });
  }

  const body = await request.json();
  const { model, entry } = body;

  switch (model) {
    case 'article':
      // 重新验证具体文章页和列表页
      revalidatePath(`/blog/${entry.slug}`);
      revalidatePath('/blog');
      revalidateTag('articles');
      break;
    case 'category':
      revalidatePath(`/category/${entry.slug}`);
      revalidatePath('/blog');
      break;
    default:
      // 全站重新验证
      revalidatePath('/', 'layout');
  }

  return NextResponse.json({ revalidated: true, timestamp: Date.now() });
}
```

## SEO数据预检查中间层

在模板渲染前，添加SEO数据完整性检查：

```typescript
// lib/seo-validator.ts
interface SEOValidationResult {
  isValid: boolean;
  warnings: string[];
  errors: string[];
}

export function validateSEOData(seo: any): SEOValidationResult {
  const warnings: string[] = [];
  const errors: string[] = [];

  // 必需字段检查
  if (!seo.title) errors.push('缺少页面标题');
  if (!seo.description) errors.push('缺少Meta Description');
  if (!seo.canonicalUrl) warnings.push('未设置Canonical URL');

  // 长度检查
  if (seo.title && seo.title.length > 60) {
    warnings.push(`标题过长 (${seo.title.length}/60)，可能被截断`);
  }
  if (seo.title && seo.title.length < 20) {
    warnings.push(`标题过短 (${seo.title.length}/20)，利用率不足`);
  }
  if (seo.description && seo.description.length > 160) {
    warnings.push(`描述过长 (${seo.description.length}/160)，可能被截断`);
  }
  if (seo.description && seo.description.length < 70) {
    warnings.push(`描述过短 (${seo.description.length}/70)，利用率不足`);
  }

  // OG标签检查
  if (!seo.ogImage) warnings.push('缺少OG图片，社交分享效果不佳');

  return {
    isValid: errors.length === 0,
    warnings,
    errors,
  };
}
```

> **提示**：模板与API对接的核心原则是"内容与展示分离，SEO数据结构化"。无论使用哪种技术栈，都应确保SEO相关数据（标题、描述、结构化数据等）是内容模型的一等公民，而非后期附加的属性。
